/*
 * jquery.flot.tooltip
 *
 * description: easy-to-use tooltips for Flot charts
 * version: 0.6.1
 * author: Krzysztof Urbas @krzysu [myviews.pl]
 * website: https://github.com/krzysu/flot.tooltip
 *
 * build on 2013-07-10
 * released under MIT License, 2012
*/
(function(t){var i={tooltip:!1,tooltipOpts:{content:"%s | X: %x | Y: %y",xDateFormat:null,yDateFormat:null,shifts:{x:10,y:20},defaultTheme:!0,onHover:function(){}}},o=function(t){this.tipPosition={x:0,y:0},this.init(t)};o.prototype.init=function(i){var o=this;i.hooks.bindEvents.push(function(i,e){if(o.plotOptions=i.getOptions(),o.plotOptions.tooltip!==!1&&void 0!==o.plotOptions.tooltip){o.tooltipOptions=o.plotOptions.tooltipOpts;var s=o.getDomElement();t(i.getPlaceholder()).bind("plothover",function(t,i,e){if(e){var n;n=o.stringFormat(o.tooltipOptions.content,e),s.html(n),o.updateTooltipPosition({x:i.pageX,y:i.pageY}),s.css({left:o.tipPosition.x+o.tooltipOptions.shifts.x,top:o.tipPosition.y+o.tooltipOptions.shifts.y}).show(),"function"==typeof o.tooltipOptions.onHover&&o.tooltipOptions.onHover(e,s)}else s.hide().html("")}),e.mousemove(function(t){var i={};i.x=t.pageX,i.y=t.pageY,o.updateTooltipPosition(i)})}})},o.prototype.getDomElement=function(){var i;return t("#flotTip").length>0?i=t("#flotTip"):(i=t("<div />").attr("id","flotTip"),i.appendTo("body").hide().css({position:"absolute"}),this.tooltipOptions.defaultTheme&&i.css({background:"#fff","z-index":"100",padding:"0.4em 0.6em","border-radius":"0.5em","font-size":"0.8em",border:"1px solid #111",display:"inline-block","white-space":"nowrap"})),i},o.prototype.updateTooltipPosition=function(i){var o=t("#flotTip").outerWidth()+this.tooltipOptions.shifts.x,e=t("#flotTip").outerHeight()+this.tooltipOptions.shifts.y;i.x-t(window).scrollLeft()>t(window).innerWidth()-o&&(i.x-=o),i.y-t(window).scrollTop()>t(window).innerHeight()-e&&(i.y-=e),this.tipPosition.x=i.x,this.tipPosition.y=i.y},o.prototype.stringFormat=function(t,i){var o=/%p\.{0,1}(\d{0,})/,e=/%s/,s=/%x\.{0,1}(?:\d{0,})/,n=/%y\.{0,1}(?:\d{0,})/;return"function"==typeof t&&(t=t(i.series.label,i.series.data[i.dataIndex][0],i.series.data[i.dataIndex][1])),i.series.percent!==void 0&&(t=this.adjustValPrecision(o,t,i.series.percent)),i.series.label!==void 0&&(t=t.replace(e,i.series.label)),this.isTimeMode("xaxis",i)&&this.isXDateFormat(i)&&(t=t.replace(s,this.timestampToDate(i.series.data[i.dataIndex][0],this.tooltipOptions.xDateFormat))),this.isTimeMode("yaxis",i)&&this.isYDateFormat(i)&&(t=t.replace(n,this.timestampToDate(i.series.data[i.dataIndex][1],this.tooltipOptions.yDateFormat))),"number"==typeof i.series.data[i.dataIndex][0]&&(t=this.adjustValPrecision(s,t,i.series.data[i.dataIndex][0])),"number"==typeof i.series.data[i.dataIndex][1]&&(t=this.adjustValPrecision(n,t,i.series.data[i.dataIndex][1])),i.series.xaxis.tickFormatter!==void 0&&(t=t.replace(s,i.series.xaxis.tickFormatter(i.series.data[i.dataIndex][0],i.series.xaxis))),i.series.yaxis.tickFormatter!==void 0&&(t=t.replace(n,i.series.yaxis.tickFormatter(i.series.data[i.dataIndex][1],i.series.yaxis))),t},o.prototype.isTimeMode=function(t,i){return i.series[t].options.mode!==void 0&&"time"===i.series[t].options.mode},o.prototype.isXDateFormat=function(){return this.tooltipOptions.xDateFormat!==void 0&&null!==this.tooltipOptions.xDateFormat},o.prototype.isYDateFormat=function(){return this.tooltipOptions.yDateFormat!==void 0&&null!==this.tooltipOptions.yDateFormat},o.prototype.timestampToDate=function(i,o){var e=new Date(i);return t.plot.formatDate(e,o)},o.prototype.adjustValPrecision=function(t,i,o){var e,s=i.match(t);return null!==s&&""!==RegExp.$1&&(e=RegExp.$1,o=o.toFixed(e),i=i.replace(t,o)),i};var e=function(t){new o(t)};t.plot.plugins.push({init:e,options:i,name:"tooltip",version:"0.6.1"})})(jQuery);

/*
 * jquery.flot.tooltip
 *
 * desc:	create tooltip with values of hovered point on the graph,
 support many series, time mode, stacking
 you can set custom tip content (also with use of HTML tags) and precision of values
 * version:	0.5
 * author: 	Krzysztof Urbas @krzysu [myviews.pl]
 * modify:  SKELETON9@9#, https://github.com/skeleton9/flot.tooltip
 * website:	https://github.com/krzysu/flot.tooltip
 *
 * released under MIT License, 2012
 */

(function ($) {
    var options = {
        tooltip: false, //boolean
        tooltipOpts: {
            content: "%s | X: %x | Y: %y.2", //%s -> series label, %x -> X value, %y -> Y value, %x.2 -> precision of X value, %p.2 -> percentage of pie or stacked with precision
            dateFormat: "%y-%0m-%0d",
            shifts: {
                x: 10,
                y: 20
            },
            defaultTheme: true,
            labelRegex: null      //use regex to process label
        }
    };

    var init = function(plot) {
        var adjustLabel = null;
        var tipPosition = {x: 0, y: 0};
        var opts = plot.getOptions();
        var processed = false;
        var stackSums = {};

        var updateTooltipPosition = function(pos) {
            tipPosition.x = pos.x;
            tipPosition.y = pos.y;
        };

        var onMouseMove = function(e) {

            var pos = {x: 0, y: 0};
            pos.x = e.pageX;
            pos.y = e.pageY;

            updateTooltipPosition(pos);
        };

        var timestampToDate = function(tmst) {

            var theDate = new Date(tmst);

            return $.plot.formatDate(theDate, opts.tooltipOpts.dateFormat);
        };

        plot.hooks.processOptions.push(function(plot, options)
        {
            if(options.tooltipOpts.labelRegex)
            {
                adjustLabel = options.tooltipOpts.labelRegex;
            }
            if(options.series.stack) // support percentage for stacked chart, add by skeleton9
            {
                plot.hooks.processRawData.push(processRawData);
            }
        });

        plot.hooks.bindEvents.push(function (plot, eventHolder) {

            var to = opts.tooltipOpts;
            var placeholder = plot.getPlaceholder();
            var $tip;

            if (opts.tooltip === false) return;

            if( $('#flotTip').length > 0 ){
                $tip = $('#flotTip');
            }
            else {
                $tip = $('<div />').attr('id', 'flotTip');
                $tip.appendTo('body').hide().css({position: 'absolute'});

                if(to.defaultTheme) {
                    $tip.css({
                        'background': '#fff',
                        'z-index': '10000',
                        'padding': '0.4em 0.6em',
                        'border-radius': '0.5em',
                        'font-size': '0.8em',
                        'border': '1px solid #111'
                    });
                }
            }

            $(placeholder).bind("plotclick", function (event, pos, item) {
                if (item) {
                    var tipText;

                    if(opts.xaxis.mode === "time" || opts.xaxes[0].mode === "time") {
                        tipText = stringFormat(to.content, item, timestampToDate);
                    }
                    else {
                        tipText = stringFormat(to.content, item);
                    }

                    $tip.html( tipText ).css({left: tipPosition.x + to.shifts.x, top: tipPosition.y + to.shifts.y}).show();
                }
                else {
                    $tip.hide().html('');
                }
            });

            eventHolder.mousemove(onMouseMove);
        });

        var stringFormat = function(content, item, fnct) {
            if (item.series.tooltipOpts && item.series.tooltipOpts.content){
                content = item.series.tooltipOpts.content;
            }
            var seriesPattern = /%s/;
            var xPattern = /%x\.{0,1}(\d{0,})/;
            var yPattern = /%y\.{0,1}(\d{0,})/;
            var pPattern = /%p\.{0,1}(\d{0,})/; //add by skeleton9 to support percentage in pie/stacked

            //series match
            if( typeof(item.series.label) !== 'undefined' ) {
                var label = item.series.label;
                if(adjustLabel)
                {
                    label = label.match(adjustLabel)[0]
                }
                content = content.replace(seriesPattern, label);
            }
            // xVal match
            if( typeof(fnct) === 'function' ) {
                content = content.replace(xPattern, fnct(item.series.data[item.dataIndex][0]) );
            }
            else {
                content = adjustValPrecision(xPattern, content, item.series.data[item.dataIndex][0]);
            }
            // yVal match
            content = adjustValPrecision(yPattern, content, item.series.data[item.dataIndex][1]);

            //add by skeleton9 to support percentage in pie
            if(item.series.percent)
            {
                content = adjustValPrecision(pPattern, content, item.series.percent);
            }
            else if(item.series.percents) //support for stacked percentage
            {
                content = adjustValPrecision(pPattern, content, item.series.percents[item.dataIndex])
            }

            return content;
        };

        var adjustValPrecision = function(pattern, content, value) {

            var precision;
            if( content.match(pattern) !== 'null' ) {
                if(RegExp.$1 !== '') {
                    precision = RegExp.$1;
                    value = value.toFixed(precision)
                }
                content = content.replace(pattern, value);
            }

            return content;
        };

        //set percentage for stacked chart
        function processRawData(plot, series, data, datapoints)
        {
            if (!processed)
            {
                processed = true;
                stackSums = getStackSums(plot.getData());
            }
            var num = data.length;
            series.percents = [];
            for(var j=0;j<num;j++)
            {
                var sum = stackSums[data[j][0]+""];
                if(sum>0)
                {
                    series.percents.push(data[j][1]*100/sum);
                } else {
                    series.percents.push(0);
                }
            }
        }

        //calculate summary
        function getStackSums(_data) {
            var data_len = _data.length;
            var sums = {};
            if (data_len > 0) {
                //caculate summary
                for (var i = 0; i < data_len; i++) {
                    if (_data[i].stackpercent || _data[i].stack) {
                        var key_idx = 0;
                        var value_idx = 1;
                        if (_data[i].bars && _data[i].bars.horizontal && _data[i].bars.horizontal === true) {
                            key_idx = 1;
                            value_idx = 0;
                        }
                        var num = _data[i].data.length;
                        for (var j = 0; j < num; j++) {
                            var value = 0;
                            if (_data[i].data[j][1] != null) {
                                value = _data[i].data[j][value_idx];
                            }
                            if (sums[_data[i].data[j][key_idx] + ""]) {
                                sums[_data[i].data[j][key_idx] + ""] += value;
                            } else {
                                sums[_data[i].data[j][key_idx] + ""] = value;
                            }

                        }
                    }
                }
            }
            return sums;
        }
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'tooltip',
        version: '0.5'
    });
})(jQuery);
